```
【260117】at好像还要ts高版本才支持，算了，先不用了
```

下面是一篇**工程化、机制级、可直接放进你个人知识库的笔记**，语气清晰、不啰嗦，重点突出“为什么推荐 `.at()`、为什么不能强制、什么时候必须用 `arr[index]`”。

---

# 📒 数组访问笔记

## 为什么不推荐 `arr[index]`，推荐使用 `arr.at(i)`（但 `.at()` 也有局限性）

---

## 1. 背景：JS 的数组访问本质上是不安全的

JavaScript 的数组访问语义是：

```js
arr[index] // 越界时返回 undefined，不会抛错
```

但 TypeScript 默认推断：

```ts
const v = arr[0];
// v: T   ← TS 认为一定有值
```

这会导致：

- 越界访问不会被类型系统发现
- 运行时可能出现 `undefined.toFixed()` 这种错误
- 隐性 bug 难以排查

---

## 2. 为什么推荐使用 `.at(i)`？

### 2.1 `.at()` 自动返回 `T | undefined`（更安全）

```ts
const v = arr.at(i);
// v: T | undefined
```

这让 TS 和 ESLint 能自动要求你检查 undefined。

### 2.2 `.at()` 语义更明确

- `.at()` 明确表达“可能越界”
- `.at(-1)` 支持负索引
- 更符合现代 JS 标准

### 2.3 `.at()` 更适合严格团队

在大型项目中，隐性越界是常见 bug 来源。  
`.at()` 能让代码更安全、更一致。

---

## 3. 为什么不推荐使用 `arr[index]`？

### 3.1 TS 无法检测越界风险

```ts
arr[100] // 运行时 undefined，但 TS 认为是 T
```

### 3.2 容易出现隐性 bug

例如：

```ts
arr[i].toFixed() // i 越界时会直接报错
```

### 3.3 不利于团队规范

不同人对“是否需要检查 undefined”理解不一致。

---

## 4. `.at()` 的局限性：不能用于赋值

这是 `.at()` 最大的限制，也是无法强制使用 `.at()` 的根本原因。

### ❌ 错误示例

```ts
fileSelectList.value.at(index) = val
```

`.at()` 返回的是值，不是引用，所以永远不能出现在赋值左侧。

### ✔️ 正确写法（必须用 `arr[index]` 或其他方式）

```ts
fileSelectList.value[index] = val
```

或者函数式更新：

```ts
fileSelectList.value.splice(index, 1, val)
```

---

## 5. 什么时候必须用 `arr[index]`？

### ✔️ 1. 赋值场景

```ts
arr[index] = newValue
```

### ✔️ 2. 性能敏感的循环（极少数情况）

```ts
for (let i = 0; i < arr.length; i++) {
  arr[i] = arr[i] * 2
}
```

### ✔️ 3. 需要引用语义（例如 Vue 响应式）

Vue 的响应式系统允许直接 mutate：

```ts
fileSelectList.value[index] = val
```

---

## 6. 最佳实践：读取用 `.at()`，写入用 `arr[index]` 或 `splice`

### ✔️ 读取（推荐）

```ts
const item = arr.at(i)
```

### ✔️ 写入（必须）

```ts
arr[index] = val
```

或：

```ts
arr.splice(index, 1, val)
```

---

## 7. 安全提示：如果使用 `arr[index]`，必须确保 index 安全

### 7.1 手动检查

```ts
if (index >= 0 && index < arr.length) {
  arr[index] = val
}
```

### 7.2 使用 TypeScript 的严格模式

在 `tsconfig.json` 中开启：

```json
{
  "compilerOptions": {
    "noUncheckedIndexedAccess": true
  }
}
```

这样：

```ts
arr[i] // T | undefined
```

TS 会强制你检查 undefined。

---

# 🧭 总结

|场景|推荐写法|原因|
|---|---|---|
|**读取数组元素**|`arr.at(i)`|更安全、语义更明确|
|**写入数组元素**|`arr[index] = val`|`.at()` 无法赋值|
|**函数式更新**|`splice` / `map` / `slice`|不修改原数组|
|**严格安全模式**|开启 `noUncheckedIndexedAccess`|TS 自动检查越界|

最终结论：

> **`.at()` 更安全，但不是万能的。读取推荐 `.at()`，写入必须用 `arr[index]` 或其他更新方式。使用 `arr[index]` 时务必确保 index 安全。**

---

如果你愿意，我可以帮你写一篇：

- “PocketChat 数组访问规范 v1.0”
- “为什么最终不强制 `.at()` 的技术说明”
- “数组读取 vs 写入的最佳实践”

你想继续哪一部分，我可以马上写给你。